<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on D</title>
    <link>https://dongri.github.io/post/</link>
    <description>Recent content in Posts on D</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 15 Aug 2016 22:27:53 +0900</lastBuildDate>
    <atom:link href="https://dongri.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Rust on Heroku with Docker</title>
      <link>https://dongri.github.io/post/2016-08-16-rust-heroku-docker/</link>
      <pubDate>Mon, 15 Aug 2016 22:27:53 +0900</pubDate>
      
      <guid>https://dongri.github.io/post/2016-08-16-rust-heroku-docker/</guid>
      <description>&lt;p&gt;Rustで書いたhello rustをherokuに載せてみた。
普通ならrust用のBuildpack使うのだが、今回はdockerを使うようにした。
Dockerfile、ソースコードなどはこちら&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/dongri/hello-rust&#34;&gt;https://github.com/dongri/hello-rust&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;はじめはalpineで頑張ってみようかと思ったがrustのインストールがうまく行かなくて、ubuntuに変更。
Dockerfileは以下のようになっている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;FROM ubuntu:latest

# rust, cargo buildに必要なソフトウェアインストール
RUN apt-get -y update
RUN apt-get -y install curl file sudo gcc

# rustのインストール
RUN curl -sSf https://static.rust-lang.org/rustup.sh | sh

RUN mkdir -p /app
WORKDIR /app
COPY . /app

# ビルドして ./target/release/helloバイナリを作る
RUN cargo build --release

EXPOSE 8080

# 実行
CMD /app/target/release/hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;readmeにも書いてあるがherokuはdockerをサポートしていて、pushするだけでローカルのdockerと
同じように動かせる。必要なのは、heroku-container-toolsというheroku plugin。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ heroku plugins:install heroku-container-tools
$ heroku container:push web
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでだけでherokuにアップされて動く。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://hello-rust.herokuapp.com/&#34;&gt;https://hello-rust.herokuapp.com/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Goodbye Instagram</title>
      <link>https://dongri.github.io/post/2016-08-15-goodbye-instagram/</link>
      <pubDate>Mon, 15 Aug 2016 00:32:35 +0900</pubDate>
      
      <guid>https://dongri.github.io/post/2016-08-15-goodbye-instagram/</guid>
      <description>&lt;p&gt;ついにInstagramの写真まで全部消した。API仕様が変わってからずっと投稿してなくて、写真残しても意味ないと思って全部消してしまった。&lt;/p&gt;

&lt;p&gt;Instagramは他のSNSと違って見てると気分がよくなる。
Twitterみたいに他人の悪口も無ければ毒もない。
あるのは綺麗な景色と美味しそうな食べ物と可愛いペット、見ててこの世の中は幸せだなと思うぐらいだ。&lt;/p&gt;

&lt;p&gt;しかし、それがFacebookに買われた後からかどうかは分からないが、タイムラインがFacebookのように
時系列ではなく勝手にユーザーの好みに合わせて表示されるようになったみたい。
猫にいいねたくさんすると猫の写真が優先されたり、美人の写真によくいいねをすると美人の写真が上に表示されたり、とにかく「おまら勝手に！」。&lt;/p&gt;

&lt;p&gt;実はInstagramがWeb版がない時代からAPIを使って「Stagram」という名前でブラウザでInstagramの写真見れるサービス？作って、
趣味でInstagramのiOS、Androidアプリまで作るぐらいInstagramが好きだった。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://flic.kr/s/aHskEFaE1Y&#34;&gt;https://flic.kr/s/aHskEFaE1Y&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;タイムラインが気持ち悪くパソナライズされたのと別に私がやめた理由はAPI制限だった。
前までは楽しいAPIで自分の写真はもちろん、他人の写真まで自分が好きなようにいじれた。
しかしそのAPIが6月1日から変わった、ずっとまえから変わるとブログには書いてあったがついに変わって、
ちゃんとした理由でAPIクライアントを申請して審査通らないとほとんどのAPIが使えない。
APIの制限にはそれなりの理由があると思うが、これ以上付き合いたくなくなった。&lt;/p&gt;

&lt;p&gt;有用性、透明性、正当性、、、俺みたいなやつがプライベートでそんな意識高いのサービス、アプリを作れるのか？！バカヤロー w&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>認めるエンジニア</title>
      <link>https://dongri.github.io/post/2016-08-13-engineer/</link>
      <pubDate>Sat, 13 Aug 2016 20:11:11 +0900</pubDate>
      
      <guid>https://dongri.github.io/post/2016-08-13-engineer/</guid>
      <description>&lt;p&gt;自分の弱点から言うと人を簡単に認めないこと。例えその人があることですごい成功したとしても気軽く認めないこと。&lt;/p&gt;

&lt;p&gt;でも、今まで認めたエンジニアは二人いる。一人は元L社のチームマネージャー、もう一人のはやめたAndroidエンジニア。&lt;/p&gt;

&lt;p&gt;一人目の元L社のチームマネージャーは検索エンジンや、ゲームプログラミングの出身でiOSの開発には知識はゼロと言っても過言ではない。
しかし途中で自分のコードにメモリリークじゃないの？こうやったほうがいいじゃないの？のアドバイスをしてくれた。
自分も確かにと思いながらやって、プロジェクトの終わりの飲み会でその真実を知った。
&amp;ldquo;大変だったよ、俺はiOSの知識が全く無くてお前らが書いたObjcコードを深夜3,4時まで本読みながら解読して勉強した。まあ過去の話だし、今日は飲もう！&amp;rdquo;&lt;/p&gt;

&lt;p&gt;もう一人はやめたやつだけど、厳しいやつだった。自分が作ったAPIのバグを探すのが趣味みたい。いろんな例外ケースを試してここがだめだ、そこがダメだ、と言ってくる。
言ってることが正しいので、反論することなく修正してあげる。というかあいつはなんでそんな例外ケースを思い出すんだろうと思うぐらいだ。
普段は無口で余計なことはしゃべらず、ただただ論理的にシステムを正しく設計しようとしてた。&lt;/p&gt;

&lt;p&gt;よく考えてみると二人は共通点がある。なにことも終わってから話すことだ。
先にここがもしかしてダメじゃない？とかなくて、自分まず試してから話す、要は手を動かす人達だった。
それにわざわざ仕事のアピールする人ではなかった。どっちも普段無口でコレをやるの宣言してからやるのではなく、コレをやった派だった。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>新卒SI</title>
      <link>https://dongri.github.io/post/2016-07-22-SI/</link>
      <pubDate>Fri, 22 Jul 2016 02:10:36 +0900</pubDate>
      
      <guid>https://dongri.github.io/post/2016-07-22-SI/</guid>
      <description>&lt;p&gt;新卒でSIの会社に入った。小さい会社で社員研修もくそもない。&lt;/p&gt;

&lt;p&gt;初日から社長に取引先(現場)に連れて行って面接。面接で初めて気付いた、履歴書に俺の年が2つ上がってる！しかも入社三年目。いろんなシステム開発経験あり、いろんな言語でコード書ける、いろんなデータベース触ったことあることになってる。まあ、しょうがない、知ってるふりして質問に答えた。幸いに面接パスして現場で働けるようになった。&lt;/p&gt;

&lt;p&gt;面接がそんなもんだから、同然現場では新卒扱いされない、いきなりJavaでフレームワーク作りに入る。業務関連の質問はできるけど、技術的な質問はできない雰囲気になってる。Javaもデータベースも知ってるふりしながら家に帰って必死にググる。それが数ヶ月続いたら本当にJavaもデータベースも知るようになった。&lt;/p&gt;

&lt;p&gt;今も偶にその時の社長と飲みに行くんだけど、その時の履歴書改竄の話出ると笑いながら「しょうがないじゃ、現場のマネージャーは新卒はいらないと言ってるから、、、」&lt;/p&gt;

&lt;p&gt;多分その時のよくない経験が影響してるか、その後現場が変わっても転職して別の会社に行っても業務関連の質問はよくするけど、技術的な質問はあんまりしないでググるか、本を買うことになってる。&lt;/p&gt;

&lt;p&gt;幸いに途中で師匠に出会えていろいろ勉強ができた。技術だけではなく、社会人としての常識的なものも勉強できた。&lt;/p&gt;

&lt;p&gt;偶に思うのは、もしちゃんとした社員研修もあって、何でも聞ける先輩がいる会社に新卒で入ったら俺はどれだけできる人間になったかなとwww。その逆もありうるけどね。&lt;/p&gt;

&lt;p&gt;(今日ツイッターで「新卒SI」についてブログ書くと宣言したので、ここまで書くか)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hello Rust</title>
      <link>https://dongri.github.io/post/2016-07-13-hello-rust/</link>
      <pubDate>Wed, 13 Jul 2016 23:35:22 +0900</pubDate>
      
      <guid>https://dongri.github.io/post/2016-07-13-hello-rust/</guid>
      <description>

&lt;h1 id=&#34;install&#34;&gt;Install&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ brew search rust
multirust    rust    uncrustify
$ brew install rust

$ rustc --version
rustc 1.10.0
$
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;hello-world&#34;&gt;hello world&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;$ vim hello.rs
fn main() {
    println!(&amp;quot;Hello Rust!&amp;quot;);
}

$ rustc hello.rs
$ ./hello
Hello Rust!
$
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Wireless adb</title>
      <link>https://dongri.github.io/post/2016-05-10-wireless-adb/</link>
      <pubDate>Tue, 10 May 2016 22:21:05 +0900</pubDate>
      
      <guid>https://dongri.github.io/post/2016-05-10-wireless-adb/</guid>
      <description>

&lt;p&gt;毎回USB繋げるのが面倒。&lt;/p&gt;

&lt;p&gt;wifi環境でandroid adb shellできるようにした。&lt;/p&gt;

&lt;h3 id=&#34;adb-tcpip-listen-port&#34;&gt;adb tcpip listen_port&lt;/h3&gt;

&lt;p&gt;USBで繋げて&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ adb tcpip 5555
restarting in TCP mode port: 5555
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;adb-connect-ip-address-lesten-port&#34;&gt;adb connect ip_address:lesten_port&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ adb connect 192.168.10.5:5555
connected to 192.168.10.5:5555

$ adb devices
List of devices attached
192.168.10.5:5555       device
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;adb-shell&#34;&gt;adb shell&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ adb shell
shell@bullhead:/ $ su
root@bullhead:/ # ls -la
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでUSBケーブルなくてもadb shellで繋げるようになった。&lt;/p&gt;

&lt;h3 id=&#34;warning&#34;&gt;Warning&lt;/h3&gt;

&lt;p&gt;このまま放置しておくとIPアドレスバレると誰からもadbで入れるので、終わったら adb usbでusbモードに戻しておきましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ adb usb
restarting in USB mode
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;追記&#34;&gt;追記&lt;/h3&gt;

&lt;p&gt;wifi環境が変わったりすると不安定になるので、app使ったほうが簡単だし、安全&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://play.google.com/store/apps/details?id=com.ttxapps.wifiadb&#34;&gt;https://play.google.com/store/apps/details?id=com.ttxapps.wifiadb&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nexus 5X クリーンインストール &amp; Root化</title>
      <link>https://dongri.github.io/post/2016-05-03-nexus-root/</link>
      <pubDate>Tue, 03 May 2016 01:36:00 +0900</pubDate>
      
      <guid>https://dongri.github.io/post/2016-05-03-nexus-root/</guid>
      <description>

&lt;h2 id=&#34;factory-image&#34;&gt;Factory Image&lt;/h2&gt;

&lt;p&gt;Googleが公開しているNexus端末向けの初期ROMデータのことを言います。
Factory Imageには、「system・boot（Kernel）・recovery・bootloader・radio・userdata・cache」などの各領域のイメージが含まれており、
それらを端末に書き込むことで領域を完全に初期化することが出来ます。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developers.google.com/android/nexus/images&#34;&gt;https://developers.google.com/android/nexus/images&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;nexus5xのところの最新のものをダウンロードして解凍する&lt;/p&gt;

&lt;h2 id=&#34;oemロック解除&#34;&gt;OEMロック解除&lt;/h2&gt;

&lt;p&gt;開発者向けオプションで「OEMロック解除を有効にする」にチェックを入れる&lt;/p&gt;

&lt;h2 id=&#34;ブートローダーをアンロック&#34;&gt;ブートローダーをアンロック&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ adb reboot bootloader // もしくは、電源ボタンとボリュームダウンボタンを同時に長押し
$ fastboot oem unlock
...
OKAY [ 20.966s]
finished. total time: 20.966s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでbootloaderがunlockの状態になる&lt;/p&gt;

&lt;p&gt;&lt;code&gt;DEVICE STATE - locked&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;↓&lt;/p&gt;

&lt;p&gt;&lt;code&gt;DEVICE STATE - unlocked&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;flash-all&#34;&gt;flash-all&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ cd bullhead-mhc19q
$ ./flash-all.sh
...
OKAY [  0.214s]
writing &#39;cache&#39;...
OKAY [  0.061s]
rebooting...

finished. total time: 86.174s
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;カスタムリカバリの導入&#34;&gt;カスタムリカバリの導入&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://twrp.me/devices/lgnexus5x.html&#34;&gt;https://twrp.me/devices/lgnexus5x.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Download Links で 最新のimgファイルダウンロードする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ fastboot flash recovery twrp-3.0.2-0-bullhead.img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ブートローダー画面から「Recovery mode」を選択すると導入したTWRPを起動できるようなりました。&lt;/p&gt;

&lt;h2 id=&#34;root化&#34;&gt;Root化&lt;/h2&gt;

&lt;p&gt;SuperSUの最新版を見つけて入れる。バージョンが違うとAndroid自体が起動できなかったりするのでご注意を&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://download.chainfire.eu/932/SuperSU/BETA-SuperSU-v2.71-20160331103524.zip&#34;&gt;https://download.chainfire.eu/932/SuperSU/BETA-SuperSU-v2.71-20160331103524.zip&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;BETA-SuperSU-v2.71-20160331103524.zipを端末に転送して、install&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ adb push BETA-SuperSU-v2.71-20160331103524.zip /sdcard/
4103 KB/s (4015219 bytes in 0.955s)
$ adb reboot bootloader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Recovery modeを選択して決定、「Install」より先ほどダウンロードしたSuperSUを選択して書き込む。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://g.co/ABH&#34;&gt;http://g.co/ABH&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;警告でるが、電源ボタンを２回押して続ける。&lt;/p&gt;

&lt;p&gt;再起動されるが、めっちゃ遅い&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;.&lt;/p&gt;

&lt;p&gt;これでroot取れた。&lt;/p&gt;

&lt;p&gt;やり放題。ubuntu入れて、webサーバー立てる。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>エンジニア軽蔑チェーン</title>
      <link>https://dongri.github.io/post/2016-02-22-the-programmer-hierarchy/</link>
      <pubDate>Tue, 23 Feb 2016 00:05:42 +0900</pubDate>
      
      <guid>https://dongri.github.io/post/2016-02-22-the-programmer-hierarchy/</guid>
      <description>

&lt;h2 id=&#34;言語編&#34;&gt;言語編&lt;/h2&gt;

&lt;p&gt;Functional Programmingをわかるエンジニアはよくデザインパターンを口にするエンジニアを軽蔑する。
よくデザインパターンを口にするエンジニアは「そのように書くとオブジェクト指向ではない」と言うエンジニアを軽蔑する。
「そのように書くとオブジェクト指向ではない」と言うエンジニアは「重複するコードをfunctionにまとめばいいじゃ」と言ってるエンジニアを軽蔑する。
コードをコピしてあっちこっちに貼り付けるエンジニアはPMを軽蔑する。&lt;/p&gt;

&lt;p&gt;アセンブラ書くエンジニアはC言語書くエンジニアを軽蔑する。
C言語書くエンジニアはC++書くを軽蔑する。
C++書くエンジニアはC#書くエンジニアを軽蔑する。
C#書くエンジニアはHTMLを一種のプログラミング言語と思ってるデザイナーを軽蔑する。&lt;/p&gt;

&lt;p&gt;Python3エンジニアはPython2エンジニアを軽蔑する。&lt;/p&gt;

&lt;p&gt;iOSエンジニアはAndroidエンジニアを軽蔑する。
AndroidエンジニアはWindows Phoneエンジニアを軽蔑する。&lt;/p&gt;

&lt;p&gt;一年のSwift経験あるエンジニアは5年のObjective-C経験持つエンジニアを軽蔑する。
Objective-C書くエンジニアはPhoneGap書くエンジニアを軽蔑する。&lt;/p&gt;

&lt;p&gt;React.js書くエンジニアはAngularJS書くエンジニアを軽蔑する。
AngularJS書くエンジニアはjQuery書くエンジニアを軽蔑する。
jQuery書くエンジニアはVanilla JSを書くエンジニアを軽蔑する。
Vanilla JS書くエンジニアはIE使用者を軽蔑する。&lt;/p&gt;

&lt;p&gt;debuggerを使えるエンジニアはassertを使ってるエンジニアを軽蔑する。
assertを使えるエンジニアはprint()しか書けないエンジニアを軽蔑する。
console.logでdebugするエンジニアはalertでdebugするエンジニアを軽蔑する。&lt;/p&gt;

&lt;p&gt;Ruby on Railsエンジニアはその他すべての言語のエンジニアを軽蔑する。&lt;/p&gt;

&lt;p&gt;すべてのエンジニアはPHPエンジニアを軽蔑する。&lt;/p&gt;

&lt;h2 id=&#34;ツール編&#34;&gt;ツール編&lt;/h2&gt;

&lt;p&gt;text editorを使ってるエンジニアはIDEを使ってるエンジニアを軽蔑する。&lt;/p&gt;

&lt;p&gt;Vim使ってるエンジニアはEmacs使ってるエンジニアを軽蔑する、Emacs使ってるエンジニアはVimを使ってるエンジニアを軽蔑する。
VimとEmacs使ってるエンジニアはほかすべてのtext editorを使ってるエンジニアを軽蔑する。例えば：atom, sublime, windows editor&lt;/p&gt;

&lt;p&gt;Android Studioを使ってるか、IntelliJ IDEAを使ってるエンジニアはEclipse使ってるエンジニアを軽蔑する。
Eclipse使ってるエンジニアはNetBeans使ってるエンジニアを軽蔑する。&lt;/p&gt;

&lt;p&gt;GitかMercurialを使ってるエンジニアはSubversionを使ってるエンジニアを軽蔑する。
Subversionを使ってるエンジニアはDropboxでバージョン管理してるエンジニアを軽蔑する。
Dropboxでバージョン管理してるエンジニアはバージョン管理しないエンジニアを軽蔑する。&lt;/p&gt;

&lt;p&gt;Githubを知ってるエンジニアはGithubを知らないエンジニアを軽蔑する。
Githubでprivate repoを持ってるエンジニアは無料repoのためBitBucketに行っちゃうエンジニアを軽蔑する。&lt;/p&gt;

&lt;p&gt;Zsh使ってるエンジニアはBashを使ってるエンジニアを軽蔑する。
Bashを使ってるエンジニアはCygwinを使ってるエンジニアを軽蔑する。
Cygwinを使ってるエンジニアはGUIツール使ってるエンジニアを軽蔑する。&lt;/p&gt;

&lt;p&gt;IRCを使ってるエンジニアはHipChatを使ってるエンジニアを軽蔑する。
HipChatを使ってるエンジニアはSlackを使ってるデザイナーを軽蔑する。&lt;/p&gt;

&lt;p&gt;reStructuredTextで文章作成するエンジニアはMarkdownで文章作成するエンジニアを軽蔑する。
Markdownで文章作成するエンジニアはHTMLで文章作成するエンジニアを軽蔑する。
HTMLで文章作成するエンジニアは文章書かないエンジニアを軽蔑する。
LaTeX使って文章作成するエンジニアはすべてのエンジニアを軽蔑する&lt;/p&gt;

&lt;p&gt;Nginxを使ってるエンジニアはApacheを使ってるエンジニアを軽蔑する。
Apacheを使ってるエンジニアはIISを使ってるエンジニアを軽蔑する。&lt;/p&gt;

&lt;p&gt;Dockerでサーバー構築するエンジニアはAnsible、Puppetでサーバー構築するエンジニアを軽蔑する。
Ansible、Puppetでサーバー構築するエンジニアはFabricでサーバー構築するエンジニアを軽蔑する。
Fabricでサーバー構築するエンジニアは手動SSHするエンジニアを軽蔑する。&lt;/p&gt;

&lt;h2 id=&#34;os編&#34;&gt;OS編&lt;/h2&gt;

&lt;p&gt;Mac OS X使ってるエンジニアはLinux使ってるエンジニアを軽蔑する。
Linux使ってるエンジニアはWindows使ってるエンジニアを軽蔑する。&lt;/p&gt;

&lt;p&gt;Debian使ってるエンジニアはUbuntu使ってるエンジニアを軽蔑する。
Ubuntu使ってるエンジニアは非LTS版Ubuntuを使ってるエンジニアを軽蔑する。&lt;/p&gt;

&lt;h2 id=&#34;ハードウエア編&#34;&gt;ハードウエア編&lt;/h2&gt;

&lt;p&gt;MacBook Pro Retina使ってるエンジニアはMacBook Air使ってるエンジニアを軽蔑する。
MacBook Air使ってるエンジニアはThinkPad使ってるエンジニアを軽蔑する。
そして、Raspberry Piを使ってるエンジニアはMacBook Pro Retinaを使ってるエンジニアを軽蔑する。&lt;/p&gt;

&lt;h2 id=&#34;職場編&#34;&gt;職場編&lt;/h2&gt;

&lt;p&gt;ハードウェアエンジニアはソフトウェアエンジニアを軽蔑する。&lt;/p&gt;

&lt;p&gt;OSを書くエンジニアはWebエンジニアを軽蔑する。
WebエンジニアはDesktop Applicationを書くエンジニアを軽蔑する。&lt;/p&gt;

&lt;p&gt;バックエンドエンジニアはフロントエンジニアを軽蔑する。&lt;/p&gt;

&lt;p&gt;エンジニアとデザイナーはお互いに軽蔑する。&lt;/p&gt;

&lt;p&gt;Test-Drivenエンジニアは先にコードを書いて後でtestを書くエンジニアを軽蔑する。
先にコード書いて後でtest書くエンジニアはtest書かないエンジニアを軽蔑する。
test書かないエンジニアは頻繁に仕様変更するPMを軽蔑する。&lt;/p&gt;

&lt;p&gt;資格持ってないエンジニアは資格をたくさん持ってるエンジニアを軽蔑する。&lt;/p&gt;

&lt;p&gt;私服で出社するエンジニアはスーツ着て出社するエンジニアを軽蔑する。&lt;/p&gt;

&lt;h2 id=&#34;終わり&#34;&gt;終わり&lt;/h2&gt;

&lt;p&gt;wechat moments流れてた記事が面白くで日本語にしました。これ10年後に見ると面白いかも知らないですね。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hugo</title>
      <link>https://dongri.github.io/post/2016-01-17-hugo/</link>
      <pubDate>Sun, 17 Jan 2016 15:20:15 +0900</pubDate>
      
      <guid>https://dongri.github.io/post/2016-01-17-hugo/</guid>
      <description>

&lt;p&gt;macクリーンインストールした後、middlemanのインストールでgemにバージョンとかでいろいろ引っかかったので、hugoに引っ越しするようにした。
もともとビルドが遅いmiddlemanそんなに好きではなかったし、いいきっかけたと思って引越しした。いい感じ。&lt;/p&gt;

&lt;h3 id=&#34;hgが必要なのでhgをインストールする&#34;&gt;hgが必要なのでhgをインストールする&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ brew install hg
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;hugoインストール&#34;&gt;hugoインストール&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ go get -v github.com/spf13/hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;site作成&#34;&gt;site作成&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new site dongri.github.io
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;テーマを取得&#34;&gt;テーマを取得&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ cd dongri.github.io
$ git clone --recursive https://github.com/spf13/hugoThemes themes
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;テーマ設定&#34;&gt;テーマ設定&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ vim config.toml
...
theme = &amp;quot;boro&amp;quot;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;post作成&#34;&gt;post作成&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new post/2016-01-17-hugo.md
$ vim post/2016-01-17-hugo.md
+++
date = &amp;quot;2016-01-17T15:20:15+09:00&amp;quot;
title = &amp;quot;Hugo&amp;quot;
tags = [&amp;quot;blog&amp;quot;]
+++

hogehoge
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;サーバー起動して確認&#34;&gt;サーバー起動して確認&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server -w
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;github-pagesにデプロイ&#34;&gt;github pagesにデプロイ&lt;/h3&gt;

&lt;p&gt;hugo siteをrepoAにして、publicをsubtreeで username.github.io にして毎回pushする。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;deploy.sh&lt;/code&gt; を作成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash

echo -e &amp;quot;Deploying updates to GitHub...&amp;quot;

# Build the project.
hugo

# Add changes to git.
git add -A

# Commit changes.
msg=&amp;quot;rebuilding site `date`&amp;quot;
if [ $# -eq 1 ]
  then msg=&amp;quot;$1&amp;quot;
fi
git commit -m &amp;quot;$msg&amp;quot;

# Push source and build repos.
git push origin master
git subtree push --prefix=public git@github.com:dongri/dongri.github.io.git master
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Android Stagefright</title>
      <link>https://dongri.github.io/post/2015-07-28-android-stagefright/</link>
      <pubDate>Tue, 28 Jul 2015 11:28:57 +0900</pubDate>
      
      <guid>https://dongri.github.io/post/2015-07-28-android-stagefright/</guid>
      <description>

&lt;p&gt;詳しいことはこちら。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://jp.techcrunch.com/2015/07/28/20150727nasty-bug-lets-hackers-into-nearly-any-android-phone-using-nothing-but-a-message/&#34;&gt;Androidに最悪の脆弱性発見―ビデオメッセージを受信するだけでデバイスが乗っ取られる&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ということで、まずSIMを抜いてOSのバージョンアップするようにした。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://plus.google.com/+CyanogenMod/posts/7iuX21Tz7n8&#34;&gt;CyanogenMod: Recent Stagefright issues&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;zip-fileダウンロードしてインストール&#34;&gt;Zip Fileダウンロードしてインストール&lt;/h3&gt;

&lt;p&gt;こちらから最新版cm-12.1をダウンロード。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://download.cyanogenmod.org/?device=bacon&#34;&gt;https://download.cyanogenmod.org/?device=bacon&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ adb push cm-12.1-20150728-NIGHTLY-bacon.zip /sdcard/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TWRPでinstallを選択して、cm-12.1-20150728-NIGHTLY-bacon.zipを選択してインストール&lt;/p&gt;

&lt;h3 id=&#34;google-appsインストール&#34;&gt;Google Appsインストール&lt;/h3&gt;

&lt;p&gt;CMではデフォルトでGoogle Apps入ってないので、追加でインストールする。
こちらからarmバージョンをダウンロードする。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/cgapps/vendor_google&#34;&gt;https://github.com/cgapps/vendor_google&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ adb push gapps-5.1-arm-2015-07-17-13-29.zip /sdcard/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TWRPでinstallを選択して、gapps-5.1-arm-2015-07-17-13-29.zipを選択してインストール&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Goodbye Heroku</title>
      <link>https://dongri.github.io/post/2015-05-11-goodbye-heroku/</link>
      <pubDate>Mon, 11 May 2015 11:28:57 +0900</pubDate>
      
      <guid>https://dongri.github.io/post/2015-05-11-goodbye-heroku/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.flickr.com/photos/dongriat/16899138724&#34; title=&#34;heroku_shot by Dongri Jin, 於 Flickr&#34;&gt;&lt;img src=&#34;https://c1.staticflickr.com/9/8707/16899138724_1bc1099219_z.jpg&#34; width=&#34;640&#34; height=&#34;479&#34; alt=&#34;heroku_shot&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;これが2007年同時のherokuでした。エディタ使わずブラウザでコード書いてSaveするとRailsが動く！素晴らしい！&lt;/p&gt;

&lt;p&gt;その後gitが流行り始めgit pushでデプロイできるようになりましたね。heroku buttonも出てOne Clickでデプロイできるようになったり。&lt;/p&gt;

&lt;p&gt;2007年から今まで使ってて、Privateのプロジェクトも一時には会社のプロジェクトにも使いました。&lt;/p&gt;

&lt;p&gt;初めはRubyだけだったのが、今はjava, scala, php, python, nodejs, goまでサポートしてます。最近はdockerもサポートするので、言語問わなくデプロイできちゃいますね。&lt;/p&gt;

&lt;p&gt;herokuの特徴と言えばとりあえず動かせるを場を提供する。そのかわりファイルアップロードできない、一定時間でスリープ、などいろいろ制限されるけど、sandboxとしては十分で便利なプラットフォームです。&lt;/p&gt;

&lt;p&gt;自分のリポジトリ数えてみたらびっくりしました。50個近くのアプリがデプロイされてました。(ほとんどがゴミ w w w)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.heroku.com/archives/2015/5/7/new-dyno-types-public-beta&#34;&gt;https://blog.heroku.com/archives/2015/5/7/new-dyno-types-public-beta&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;こんなので自分の遊びがなくなりました。$7 払えないわけではない。しかし昔みたいにとりあえずherokuみたいな感じにはなれない。&lt;/p&gt;

&lt;p&gt;herokuの代わりのものを Google Cloud, AWS も検討してみましたが、結局は DigitalOceanでサーバー立てて、&lt;a href=&#34;https://github.com/progrium/dokku&#34;&gt;dokku&lt;/a&gt; 入れて自分専用の遊び場を作ることにしました。&lt;/p&gt;

&lt;p&gt;今のところ4GBでnode, rails, goなど10個のcontainer立ち上げても問題なさそうです。&lt;/p&gt;

&lt;p&gt;heroku長い間お世話になりました！&lt;/p&gt;

&lt;p&gt;Goodbye! Heroku!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OnePlus One</title>
      <link>https://dongri.github.io/post/2015-04-14-oneplus-one/</link>
      <pubDate>Tue, 14 Apr 2015 11:28:57 +0900</pubDate>
      
      <guid>https://dongri.github.io/post/2015-04-14-oneplus-one/</guid>
      <description>

&lt;h3 id=&#34;1-bootloader-unlock&#34;&gt;1. Bootloader Unlock&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ adb reboot bootloader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CyanogenMod Logoが出る&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ fastboot oem unlock
...
OKAY [  0.005s]
finished. total time: 0.005s
$  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-install-twrp&#34;&gt;2. Install TWRP&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://dl.twrp.me/bacon/&#34;&gt;http://dl.twrp.me/bacon/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;twrp-2.8.6.0-bacon.img ダウンロード&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ adb reboot bootloader

$ fastboot flash recovery twrp-2.8.6.0-bacon.img
target reported max download size of 536870912 bytes
sending &#39;recovery&#39; (10180 KB)...
OKAY [  0.323s]
writing &#39;recovery&#39;...
OKAY [  0.132s]
finished. total time: 0.455s

$ fastboot reboot
rebooting...

finished. total time: 0.005s
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;強制的にtwrp起動する&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ fastboot boot twrp-2.8.6.0-bacon.img
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-wipe&#34;&gt;3. Wipe&lt;/h3&gt;

&lt;p&gt;電源ボタンとボリュームダウンボタンを同時に押してTWRPを起動する。
TWRP起動したらwipeを選択して全ての削除する！&lt;/p&gt;

&lt;h3 id=&#34;4-install-oxygen-os&#34;&gt;4. Install Oxygen OS&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://oneplus.net/oxygenos&#34;&gt;https://oneplus.net/oxygenos&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;oxygenos_1.0.0.zip ダウンロード&lt;/p&gt;

&lt;p&gt;oxygenos_1.0.0.zip を解凍して oxygenos_1.0.0.flashable.zip を OnePlus One に入れる&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ adb push oxygen_1.0.0_flashable.zip /sdcard/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TWRPでinstallを選択して、oxygen_1.0.0_flashable.zipを選択してインストール&lt;/p&gt;

&lt;p&gt;SuperSUもインストールするようにする。デバイスが再起動したらもう一度SuperSUを起動してROOTを取る&lt;/p&gt;

&lt;p&gt;以上&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OxygenOS</title>
      <link>https://dongri.github.io/post/2015-04-05-oxygenos/</link>
      <pubDate>Sun, 05 Apr 2015 11:28:57 +0900</pubDate>
      
      <guid>https://dongri.github.io/post/2015-04-05-oxygenos/</guid>
      <description>

&lt;p&gt;(下に追記あり)&lt;/p&gt;

&lt;p&gt;昨日出たOxygenOS 1.0.0について簡単にメモでも残そうかと思って書いた。&lt;/p&gt;

&lt;p&gt;結論から言うと、OxygenOSはやめてCyanogenmod 12Sにした。&lt;/p&gt;

&lt;p&gt;April 3 2015&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.oneplus.net/2015/04/oxygenos-is-here-2/&#34;&gt;OxygenOS is Here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://oneplus.net/oxygenos&#34;&gt;https://oneplus.net/oxygenos&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://forums.oneplus.net/threads/oxygenos-is-here-installation-guide.289398/&#34;&gt;Installation Guide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;インストールの流れは&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Bootloader Unlock&lt;/li&gt;
&lt;li&gt;TWRPをインストール&lt;/li&gt;
&lt;li&gt;oxygenos_1.0.0.flashable.zipを実機に転送&lt;/li&gt;
&lt;li&gt;TWRPでzip指定してインストール&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;コマンドは以下のようになる&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ adb reboot bootloader
$ fastboot oem unlock
$ fastboot flash recovery ***.img
$ fastboot reboot
or
$ fastboot boot ***.img

$ adb push oxygenos_1.0.0.flashable.zip /sdcard/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上の手順で既存OnePlus OneのCyanogenmod 11SからOxygenOSにはアップグレードしたことは成功したが、
人によって、まっさらな状態で綺麗にインストールしたいですよね（私だけ？）&lt;/p&gt;

&lt;p&gt;で、TWRPで全てのデータ削除して、0からOxygenOSをインストールしてみた。結果やばいことになった。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;そもそもステータスバー出て来ない。&lt;/li&gt;
&lt;li&gt;画面が真っ黒で壁紙設定できない。&lt;/li&gt;
&lt;li&gt;戻るボタン以外他のボタン効かない。&lt;/li&gt;
&lt;li&gt;ソフトボタンの表示設定しても出て来ない。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;２，３回インストールし直しても結果は同じだった。推測だが、既存OSからOxygenOSにアップグレードはサポートするけど、
クリーンインストールはサポートしてないかという疑惑。&lt;/p&gt;

&lt;p&gt;上で使い物にならなかったので、Cyanogenmodに頼るしかない。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://download.cyanogenmod.org/?device=bacon&amp;amp;type=nightly&#34;&gt;http://download.cyanogenmod.org/?device=bacon&amp;amp;type=nightly&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2015-04-04 04:19:52の最新版があったので、ダウンロードしてインストール。&lt;/p&gt;

&lt;p&gt;これで、綺麗な状態で綺麗にインストール出来たわけだが、CyanogenMod IncとGoogleの関係上CyanogenModにGoogle系appsを入れちゃだめなので、別途インストールするしかない。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://wiki.cyanogenmod.org/w/Google_Apps&#34;&gt;Google Apps&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ここでもよいだが、若干古い感じがする。ググって最新版をダウンロードしてインストール。&lt;/p&gt;

&lt;p&gt;その後Cyanogenmod 12Sの上にOxygenOSをインストールしてみてもダメだった。&lt;/p&gt;

&lt;p&gt;ということで、しばらくはOxygenOSは使わないことにした。&lt;/p&gt;

&lt;p&gt;以上、私の端末で起きたことでした。&lt;/p&gt;

&lt;h3 id=&#34;追記-2015-04-09&#34;&gt;追記 (2015/04/09)&lt;/h3&gt;

&lt;p&gt;もう一回oxygenos_1.0.0.zipをダウンロードしてインストールした成功。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ md5 oxygen_1.0.0_flashable.zip
MD5 (oxygen_1.0.0_flashable.zip) = 2d79312774c44d2fa2bf5bb0c877d1b7
$ vim oxygen_1.0.0_flashable.md5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;チェックしたら一致してた。前回ダメだったのは恐らくzipファイルがおかしかったかも。。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ghost On Heroku</title>
      <link>https://dongri.github.io/post/2015-02-17-ghost-on-heroku/</link>
      <pubDate>Tue, 17 Feb 2015 11:28:57 +0900</pubDate>
      
      <guid>https://dongri.github.io/post/2015-02-17-ghost-on-heroku/</guid>
      <description>

&lt;p&gt;Ghostをherokuにデプロイしてみた。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;以下はあくまでの自分の環境で、nodeとpostgresなど一通りの開発環境は整った環境です。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;ghostをローカルで動かしてみる&#34;&gt;Ghostをローカルで動かしてみる&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ cd /path/to/ghost/folder/
$ npm install --production

$ npm start
$ open http://localhost:2368
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;herokuにpg-addon追加&#34;&gt;herokuにpg addon追加&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ heroku addons:add heroku-postgresql:dev

$ heroku config
DATABASE_URL:                 postgres://{username}:{password}@ec2-***.compute-1.amazonaws.com:5432/{database}
HEROKU_POSTGRESQL_PURPLE_URL: postgres://{username}:{password}@ec2-***.compute-1.amazonaws.com:5432/{database}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;package-json-修正&#34;&gt;package.json 修正&lt;/h2&gt;

&lt;p&gt;package.jsonのdependenciesにpg追加。バージョンは固定にしたほうがいいかも。。。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;dependencies&amp;quot;: {
  ....,
  &amp;quot;pg&amp;quot;: &amp;quot;4.2.0&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;config-js-修正&#34;&gt;config.js 修正&lt;/h2&gt;

&lt;p&gt;以下の部分をproductionのところに設定する。databaseの部分は上のDATABASE_URLのところ参照&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;database: {
  client: &#39;postgres&#39;,
  connection: {
        host: &#39;ec2-***.compute-1.amazonaws.com&#39;,
        user: &#39;{username}&#39;,
        password: &#39;{password}&#39;,
        database: &#39;{database}&#39;,
        port: &#39;5432&#39;
  }
},

server: {
    host: &#39;0.0.0.0&#39;,
    port: process.env.PORT
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;procfileファイル追加&#34;&gt;Procfileファイル追加&lt;/h2&gt;

&lt;p&gt;herokuにnodejsアプリをデプロイした人にはわかると思うがProfileを作成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vim Procfile
web: node index.js --production
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;git-remote-push&#34;&gt;git remote, push&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ git init
$ git remote add origin git@heroku.com:{app}.git
$ git add .
$ git commit -m &amp;quot;Ghost&amp;quot;
$ git push origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;debug&#34;&gt;Debug&lt;/h2&gt;

&lt;p&gt;heroku上でApplication Error!&lt;/p&gt;

&lt;p&gt;log見てみる&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ heroku logs --tail

Ghost is running in development...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;developmentで実行されたようだ。&lt;/p&gt;

&lt;p&gt;NODE_ENVをproductionに設定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ heroku config:set NODE_ENV=production
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上のコマンドでenv設定とrebootするので、tailで完了確認できたら、もう一度アクセスしてみる。&lt;/p&gt;

&lt;p&gt;うまく表示されたようだ&lt;/p&gt;

&lt;h2 id=&#34;ghost設定&#34;&gt;Ghost設定&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ open http://{app}.herokuapp.com/ghost/setup/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;所感&#34;&gt;所感&lt;/h2&gt;

&lt;p&gt;設定して自分が欲しかったmarkdownで書けるようになったけど、意識高い系に似合うデザインのせいか
メモ、コードを書くにはいまいち。。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Google OAuth2</title>
      <link>https://dongri.github.io/post/2015-02-16-google-oauth2/</link>
      <pubDate>Mon, 16 Feb 2015 11:28:57 +0900</pubDate>
      
      <guid>https://dongri.github.io/post/2015-02-16-google-oauth2/</guid>
      <description>

&lt;p&gt;Google OAuth2のトークンを手動で取得メモ。通常はWebアプリはブラウザで取得してトークンとか保存すればいいのだが、
hubot scriptでcalendar情報とか取得したい場合は、そうはいかない。&lt;/p&gt;

&lt;h2 id=&#34;クライアントid作成&#34;&gt;クライアントID作成&lt;/h2&gt;

&lt;p&gt;予めGoogle Developer Console画面で、クライアントIDを作成
&lt;a href=&#34;https://console.developers.google.com/project&#34;&gt;https://console.developers.google.com/project&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;code-取得&#34;&gt;code 取得&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;https://accounts.google.com/o/oauth2/auth
?client_id={client_id}
&amp;amp;redirect_uri={callback_url}
&amp;amp;scope={scope}
&amp;amp;response_type=code
&amp;amp;approval_prompt=force
&amp;amp;access_type=offline
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;scopeは &lt;a href=&#34;https://www.googleapis.com/auth/calendar.readonly&#34;&gt;https://www.googleapis.com/auth/calendar.readonly&lt;/a&gt; など&lt;/p&gt;

&lt;p&gt;GETで上のURLを叩く。認証画面が開き、承認すると、指定したcallback_urlにcodeが返ってくる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;{callback_url}?code=4/W30HqfsDKmamqdW*****************
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;access-token-refresh-token-取得&#34;&gt;access_token, refresh_token 取得&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ curl
-d client_id={client_id}
-d client_secret={client_secret}
-d redirect_uri={callback_url}
-d grant_type=authorization_code
-d code={code} https://accounts.google.com/o/oauth2/token
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のJSON結果が返ってくる&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;access_token&amp;quot; : &amp;quot;{access_token}&amp;quot;,
  &amp;quot;token_type&amp;quot; : &amp;quot;Bearer&amp;quot;,
  &amp;quot;expires_in&amp;quot; : 3600,
  &amp;quot;refresh_token&amp;quot; : &amp;quot;{refresh_token}&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;access_tokenの情報を確認してみる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://www.googleapis.com/oauth2/v1/tokeninfo?access_token={access_token}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アクセスする度にexpires_inが減って行くのがわかる。0になると、access_tokenは失効されるので、使えない。&lt;/p&gt;

&lt;h2 id=&#34;新しいaccess-tokenを取得&#34;&gt;新しいaccess_tokenを取得&lt;/h2&gt;

&lt;p&gt;expires_inで有効期限切れるまえに以下のPOSTで新しいaccess_tokenを取得&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl
-d client_id={client_id}
-d client_secret={client_secret}
-d refresh_token={refresh_token}
-d grant_type=refresh_token https://accounts.google.com/o/oauth2/token
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上の結果、新しいexpires_inが3600の新しいaccess_tokenが返ってくる。&lt;/p&gt;

&lt;p&gt;3600秒以内にaccess_tokenを更新して使えばOK!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>